###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       16/Oct/2024  20:40:53
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\pnu10\Desktop\project_test\user\main.c
#    Command line =  
#        -f C:\Users\pnu10\AppData\Local\Temp\EWE684.tmp
#        (C:\Users\pnu10\Desktop\project_test\user\main.c -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu10\Desktop\project_test\Debug\List -o
#        C:\Users\pnu10\Desktop\project_test\Debug\Obj --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu10\Desktop\project_test\libraries\CMSIS\DeviceSupport\ -I
#        C:\Users\pnu10\Desktop\project_test\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu10\Desktop\project_test\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu10\Desktop\project_test\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu10\Desktop\project_test\user\ -I
#        C:\Users\pnu10\Desktop\project_test\user\inc\ -Ol -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  C:\Users\pnu10\Desktop\project_test\Debug\List\main.lst
#    Object file  =  C:\Users\pnu10\Desktop\project_test\Debug\Obj\main.o
#
###############################################################################

C:\Users\pnu10\Desktop\project_test\user\main.c
      1          
      2          #include "stm32f10x.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD409             BMI.N    ??__NVIC_EnableIRQ_0
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   0000000E   0x408A             LSLS     R2,R2,R1
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0xe000e100
   \   00000014   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000016   0x0940             LSRS     R0,R0,#+5
   \   00000018   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
      3          #include "stm32f10x_exti.h"
      4          #include "stm32f10x_gpio.h"
      5          #include "stm32f10x_usart.h"
      6          #include "stm32f10x_rcc.h"
      7          
      8          #include "misc.h"
      9          
     10          /* function prototype */
     11          void RCC_Configure(void);
     12          void GPIO_Configure(void);
     13          void EXTI_Configure(void);
     14          void USART1_Init(void);
     15          void NVIC_Configure(void);
     16          
     17          void EXTI15_10_IRQHandler(void);
     18          
     19          void Delay(void);
     20          void sendDataUART1(uint16_t data);
     21          
     22          //---------------------------------------------------------------------------------------------------
     23          

   \                                 In section .data, align 4
     24          int mode = 1;
   \                     mode:
   \   00000000   0x00000001         DC32 1
     25          

   \                                 In section .text, align 2, keep-with-next
     26          void RCC_Configure(void)
     27          {
   \                     RCC_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     28          	// TODO: Enable the APB2 peripheral clock using the function 'RCC_APB2PeriphClockCmd'
     29          	
     30          	/* UART TX/RX port clock enable */
     31          	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40021018
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x40021018
   \   00000010   0x6008             STR      R0,[R1, #+0]
     32          	/* Button S1, S2, S3 port clock enable */
     33                  // @@ C @@@ @@@
     34                  RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40021018
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x40021018
   \   00000020   0x6008             STR      R0,[R1, #+0]
     35          	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40021018
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x40021018
   \   00000030   0x6008             STR      R0,[R1, #+0]
     36          	/* LED port clock enable */
     37                  RCC->APB2ENR |= RCC_APB2ENR_IOPDEN;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40021018
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable9_1  ;; 0x40021018
   \   00000040   0x6008             STR      R0,[R1, #+0]
     38          	
     39          	/* USART1 clock enable */
     40          	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40021018
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   0000004C   0x....             LDR.N    R1,??DataTable9_1  ;; 0x40021018
   \   0000004E   0x6008             STR      R0,[R1, #+0]
     41          	/* Alternate Function IO clock enable */
     42          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   \   00000050   0x2101             MOVS     R1,#+1
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     43          }
   \   00000058   0xBD01             POP      {R0,PC}          ;; return
     44          

   \                                 In section .text, align 2, keep-with-next
     45          void GPIO_Configure(void)
     46          {
   \                     GPIO_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     47              GPIO_InitTypeDef GPIO_InitStructure;
     48          
     49          	// TODO: Initialize the GPIO pins using the structure 'GPIO_InitTypeDef' and the function 'GPIO_Init'
     50          	
     51              /* Button S1, S2, S3 pin setting */
     52              /* Reset(Clear) Port C CRH - User S1 Button */
     53              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_13;
   \   00000002   0xF242 0x0010      MOVW     R0,#+8208
   \   00000006   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     54              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0xF88D 0x0003      STRB     R0,[SP, #+3]
     55              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x....             LDR.N    R0,??DataTable9_2  ;; 0x40011000
   \   00000014   0x.... 0x....      BL       GPIO_Init
     56              
     57              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   00000018   0xF44F 0x6080      MOV      R0,#+1024
   \   0000001C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     58              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000020   0x2004             MOVS     R0,#+4
   \   00000022   0xF88D 0x0003      STRB     R0,[SP, #+3]
     59              GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40010c00
   \   0000002A   0x.... 0x....      BL       GPIO_Init
     60              
     61              /*
     62              GPIOC->CRL &= ~(GPIO_CRL_CNF4 | GPIO_CRL_MODE4);
     63              GPIOC->CRL |= GPIO_CRL_CNF4_1;
     64              GPIOC->BRH &= ~(GPIO_BRH_CNF10 | GPIO_CRH_MODE10);
     65              GPIOC->BRH |= GPIO_BRH_CNF10_1;
     66              GPIOC->CRH &= ~(GPIO_CRH_CNF13 | GPIO_CRH_MODE13);
     67              GPIOC->CRH |= GPIO_CRH_CNF13_1;
     68              */
     69              
     70              /* LED pin setting*/
     71              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_7;
   \   0000002E   0x209C             MOVS     R0,#+156
   \   00000030   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     72              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000034   0x2003             MOVS     R0,#+3
   \   00000036   0xF88D 0x0002      STRB     R0,[SP, #+2]
     73              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000003A   0x2010             MOVS     R0,#+16
   \   0000003C   0xF88D 0x0003      STRB     R0,[SP, #+3]
     74              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40011400
   \   00000044   0x.... 0x....      BL       GPIO_Init
     75          	
     76              /* UART pin setting */
     77              //TX
     78              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \   00000048   0xF44F 0x7000      MOV      R0,#+512
   \   0000004C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     79              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000050   0x2003             MOVS     R0,#+3
   \   00000052   0xF88D 0x0002      STRB     R0,[SP, #+2]
     80              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   00000056   0x2018             MOVS     R0,#+24
   \   00000058   0xF88D 0x0003      STRB     R0,[SP, #+3]
     81              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000005C   0x4669             MOV      R1,SP
   \   0000005E   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40010800
   \   00000060   0x.... 0x....      BL       GPIO_Init
     82              
     83              
     84              //RX
     85              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   00000064   0xF44F 0x6080      MOV      R0,#+1024
   \   00000068   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     86              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD | GPIO_Mode_IPU;
                                                  ^
Warning[Pe188]: enumerated type mixed with another type
   \   0000006C   0x2068             MOVS     R0,#+104
   \   0000006E   0xF88D 0x0003      STRB     R0,[SP, #+3]
     87              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000072   0x4669             MOV      R1,SP
   \   00000074   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40010800
   \   00000076   0x.... 0x....      BL       GPIO_Init
     88          }
   \   0000007A   0xBD01             POP      {R0,PC}          ;; return
     89          

   \                                 In section .text, align 2, keep-with-next
     90          void EXTI_Configure(void)
     91          {
   \                     EXTI_Configure: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
     92              EXTI_InitTypeDef EXTI_InitStructure;
     93          
     94          	// TODO: Select the GPIO pin (Joystick, button) used as EXTI Line using function 'GPIO_EXTILineConfig'
     95          	// TODO: Initialize the EXTI using the structure 'EXTI_InitTypeDef' and the function 'EXTI_Init'
     96          	
     97              /* Button S1 */
     98          	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource4);
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x.... 0x....      BL       GPIO_EXTILineConfig
     99              EXTI_InitStructure.EXTI_Line = EXTI_Line4;
   \   0000000A   0x2010             MOVS     R0,#+16
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    100              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0004      STRB     R0,[SP, #+4]
    101              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \   00000014   0x200C             MOVS     R0,#+12
   \   00000016   0xF88D 0x0005      STRB     R0,[SP, #+5]
    102              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xF88D 0x0006      STRB     R0,[SP, #+6]
    103              EXTI_Init(&EXTI_InitStructure);
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x.... 0x....      BL       EXTI_Init
    104          
    105              /* Button S2 */
    106              GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource10);
   \   00000026   0x210A             MOVS     R1,#+10
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       GPIO_EXTILineConfig
    107              EXTI_InitStructure.EXTI_Line = EXTI_Line10;
   \   0000002E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000032   0x9000             STR      R0,[SP, #+0]
    108              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF88D 0x0004      STRB     R0,[SP, #+4]
    109              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \   0000003A   0x200C             MOVS     R0,#+12
   \   0000003C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    110              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF88D 0x0006      STRB     R0,[SP, #+6]
    111              EXTI_Init(&EXTI_InitStructure);
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x.... 0x....      BL       EXTI_Init
    112          	
    113          	/* Button S3 */
    114              GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource13);
   \   0000004C   0x210D             MOVS     R1,#+13
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0x.... 0x....      BL       GPIO_EXTILineConfig
    115              EXTI_InitStructure.EXTI_Line = EXTI_Line13;
   \   00000054   0xF44F 0x5000      MOV      R0,#+8192
   \   00000058   0x9000             STR      R0,[SP, #+0]
    116              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    117              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \   00000060   0x200C             MOVS     R0,#+12
   \   00000062   0xF88D 0x0005      STRB     R0,[SP, #+5]
    118              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF88D 0x0006      STRB     R0,[SP, #+6]
    119              EXTI_Init(&EXTI_InitStructure);
   \   0000006C   0x4668             MOV      R0,SP
   \   0000006E   0x.... 0x....      BL       EXTI_Init
    120          
    121          	// NOTE: do not select the UART GPIO pin used as EXTI Line here
    122          }
   \   00000072   0xBD07             POP      {R0-R2,PC}       ;; return
    123          

   \                                 In section .text, align 2, keep-with-next
    124          void USART1_Init(void)
    125          {
   \                     USART1_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    126          	USART_InitTypeDef USART1_InitStructure;
    127          
    128          	// Enable the USART1 peripheral
    129          	USART_Cmd(USART1, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x....             LDR.N    R0,??DataTable9_6  ;; 0x40013800
   \   00000006   0x.... 0x....      BL       USART_Cmd
    130          	
    131          	// TODO: Initialize the USART using the structure 'USART_InitTypeDef' and the function 'USART_Init'
    132          	USART1_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    133                  USART1_InitStructure.USART_StopBits = USART_StopBits_1;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    134          	USART1_InitStructure.USART_Parity = USART_Parity_No;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    135          	USART1_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   0000001C   0x200C             MOVS     R0,#+12
   \   0000001E   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    136          	USART1_InitStructure.USART_BaudRate = 28800;
   \   00000022   0xF44F 0x40E1      MOV      R0,#+28800
   \   00000026   0x9000             STR      R0,[SP, #+0]
    137                  //?
    138                  USART1_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    139                  USART_Init(USART1, &USART1_InitStructure); 
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x....             LDR.N    R0,??DataTable9_6  ;; 0x40013800
   \   00000032   0x.... 0x....      BL       USART_Init
    140          	
    141          	// TODO: Enable the USART1 RX interrupts using the function 'USART_ITConfig' and the argument value 'Receive Data register not empty interrupt'
    142          	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
   \   00000036   0x2201             MOVS     R2,#+1
   \   00000038   0xF240 0x5125      MOVW     R1,#+1317
   \   0000003C   0x....             LDR.N    R0,??DataTable9_6  ;; 0x40013800
   \   0000003E   0x.... 0x....      BL       USART_ITConfig
    143          }
   \   00000042   0xB005             ADD      SP,SP,#+20
   \   00000044   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
    144          void LED(int mode){
   \                     LED: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    145              if (mode == 0){
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??LED_0
    146                forwardLED();
                       ^
Warning[Pe223]: function "forwardLED" declared implicitly
   \   00000008   0x.... 0x....      BL       forwardLED
    147              }
    148              if (mode == 1){
   \                     ??LED_0: (+1)
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD101             BNE.N    ??LED_1
    149                forwardLED();
                       ^
Warning[Pe223]: function "forwardLED" declared implicitly
   \   00000010   0x.... 0x....      BL       forwardLED
    150              }
    151              if (mode == 2){
   \                     ??LED_1: (+1)
   \   00000014   0x2C02             CMP      R4,#+2
   \   00000016   0xD101             BNE.N    ??LED_2
    152                backwardLED();
                       ^
Warning[Pe223]: function "backwardLED" declared implicitly
   \   00000018   0x.... 0x....      BL       backwardLED
    153              }
    154          }
   \                     ??LED_2: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    155          

   \                                 In section .text, align 2, keep-with-next
    156          void NVIC_Configure(void) {
   \                     NVIC_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    157          
    158              NVIC_InitTypeDef NVIC_InitStructure;
    159              
    160              // TODO: fill the arg you want
    161              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
   \   00000002   0xF44F 0x60E0      MOV      R0,#+1792
   \   00000006   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    162          
    163              // TODO: Initialize the NVIC using the structure 'NVIC_InitTypeDef' and the function 'NVIC_Init'
    164              NVIC_Init(&NVIC_InitStructure);
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       NVIC_Init
    165              // Button S1
    166              NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;
   \   00000010   0x200A             MOVS     R0,#+10
   \   00000012   0xF88D 0x0000      STRB     R0,[SP, #+0]
    167              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00; // TODO
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF88D 0x0001      STRB     R0,[SP, #+1]
    168              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00; // TODO
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    169              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF88D 0x0003      STRB     R0,[SP, #+3]
    170              NVIC_Init(&NVIC_InitStructure);
   \   00000028   0x4668             MOV      R0,SP
   \   0000002A   0x.... 0x....      BL       NVIC_Init
    171              // Button S2, S3
    172               NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
   \   0000002E   0x2028             MOVS     R0,#+40
   \   00000030   0xF88D 0x0000      STRB     R0,[SP, #+0]
    173              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00; // TODO
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF88D 0x0001      STRB     R0,[SP, #+1]
    174              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00; // TODO
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    175              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF88D 0x0003      STRB     R0,[SP, #+3]
    176              NVIC_Init(&NVIC_InitStructure);
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x.... 0x....      BL       NVIC_Init
    177              // UART1
    178          	// 'NVIC_EnableIRQ' is only required for USART setting
    179              NVIC_EnableIRQ(USART1_IRQn);
   \   0000004C   0x2025             MOVS     R0,#+37
   \   0000004E   0x.... 0x....      BL       __NVIC_EnableIRQ
    180              NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
   \   00000052   0x2025             MOVS     R0,#+37
   \   00000054   0xF88D 0x0000      STRB     R0,[SP, #+0]
    181              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00; // TODO
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    182              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00; // TODO
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF88D 0x0002      STRB     R0,[SP, #+2]
    183              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xF88D 0x0003      STRB     R0,[SP, #+3]
    184              NVIC_Init(&NVIC_InitStructure);
   \   0000006A   0x4668             MOV      R0,SP
   \   0000006C   0x.... 0x....      BL       NVIC_Init
    185          }
   \   00000070   0xBD01             POP      {R0,PC}          ;; return
    186          

   \                                 In section .text, align 2, keep-with-next
    187          void USART1_IRQHandler() {
   \                     USART1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    188          	uint16_t word;
    189              if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET){
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x....             LDR.N    R0,??DataTable9_6  ;; 0x40013800
   \   00000008   0x.... 0x....      BL       USART_GetITStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD014             BEQ.N    ??USART1_IRQHandler_0
    190              	// the most recent received data by the USART1 peripheral
    191                  word = USART_ReceiveData(USART1);
   \   00000010   0x....             LDR.N    R0,??DataTable9_6  ;; 0x40013800
   \   00000012   0x.... 0x....      BL       USART_ReceiveData
    192          
    193                  // TODO implement
    194                  if (word == 'a'){
   \   00000016   0x0001             MOVS     R1,R0
   \   00000018   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001A   0x2961             CMP      R1,#+97
   \   0000001C   0xD102             BNE.N    ??USART1_IRQHandler_1
    195                    mode = 1;
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0x....             LDR.N    R2,??DataTable9_7
   \   00000022   0x6011             STR      R1,[R2, #+0]
    196                  }
    197                  if(word == 'b'){
   \                     ??USART1_IRQHandler_1: (+1)
   \   00000024   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000026   0x2862             CMP      R0,#+98
   \   00000028   0xD102             BNE.N    ??USART1_IRQHandler_2
    198                    mode = 2;
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0x....             LDR.N    R1,??DataTable9_7
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    199                  }
    200          
    201                  // clear 'Read data register not empty' flag
    202              	USART_ClearITPendingBit(USART1,USART_IT_RXNE);
   \                     ??USART1_IRQHandler_2: (+1)
   \   00000030   0xF240 0x5125      MOVW     R1,#+1317
   \   00000034   0x....             LDR.N    R0,??DataTable9_6  ;; 0x40013800
   \   00000036   0x.... 0x....      BL       USART_ClearITPendingBit
    203              }
    204          }
   \                     ??USART1_IRQHandler_0: (+1)
   \   0000003A   0xBD01             POP      {R0,PC}          ;; return
    205          

   \                                 In section .text, align 2, keep-with-next
    206          void EXTI15_10_IRQHandler(void) { // when the button is pressed
   \                     EXTI15_10_IRQHandler: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    207              char msg[] = "Team10\r\n";
   \   00000002   0x4668             MOV      R0,SP
   \   00000004   0x....             LDR.N    R1,??DataTable9_8
   \   00000006   0xE891 0x001C      LDM      R1,{R2-R4}
   \   0000000A   0xE880 0x001C      STM      R0,{R2-R4}
    208              if (EXTI_GetITStatus(EXTI_Line10) != RESET) {
   \   0000000E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000012   0x.... 0x....      BL       EXTI_GetITStatus
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD00D             BEQ.N    ??EXTI15_10_IRQHandler_0
    209          		if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_10) == Bit_RESET) {
   \   0000001A   0xF44F 0x6180      MOV      R1,#+1024
   \   0000001E   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40010c00
   \   00000020   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD102             BNE.N    ??EXTI15_10_IRQHandler_1
    210          			// TODO implement
    211                            mode = 2;
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x....             LDR.N    R1,??DataTable9_7
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    212                            
    213          		}
    214          		EXTI_ClearITPendingBit(EXTI_Line10);
   \                     ??EXTI15_10_IRQHandler_1: (+1)
   \   0000002E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000032   0x.... 0x....      BL       EXTI_ClearITPendingBit
    215          	}
    216              if (EXTI_GetITStatus(EXTI_Line13) != RESET) {
   \                     ??EXTI15_10_IRQHandler_0: (+1)
   \   00000036   0xF44F 0x5000      MOV      R0,#+8192
   \   0000003A   0x.... 0x....      BL       EXTI_GetITStatus
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD019             BEQ.N    ??EXTI15_10_IRQHandler_2
    217          		if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13) == Bit_RESET) {
   \   00000042   0xF44F 0x5100      MOV      R1,#+8192
   \   00000046   0x....             LDR.N    R0,??DataTable9_2  ;; 0x40011000
   \   00000048   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD10E             BNE.N    ??EXTI15_10_IRQHandler_3
    218          			// TODO implement
    219                            for(int i = 0; msg[i] != '\n'; i++){
   \   00000050   0x2400             MOVS     R4,#+0
   \   00000052   0xE005             B.N      ??EXTI15_10_IRQHandler_4
    220                              sendDataUART1(msg[i]);
   \                     ??EXTI15_10_IRQHandler_5: (+1)
   \   00000054   0x4668             MOV      R0,SP
   \   00000056   0x5D00             LDRB     R0,[R0, R4]
   \   00000058   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005A   0x.... 0x....      BL       sendDataUART1
    221                            }
   \   0000005E   0x1C64             ADDS     R4,R4,#+1
   \                     ??EXTI15_10_IRQHandler_4: (+1)
   \   00000060   0x4668             MOV      R0,SP
   \   00000062   0x5D00             LDRB     R0,[R0, R4]
   \   00000064   0x280A             CMP      R0,#+10
   \   00000066   0xD1F5             BNE.N    ??EXTI15_10_IRQHandler_5
    222                            sendDataUART1('\n');
   \   00000068   0x200A             MOVS     R0,#+10
   \   0000006A   0x.... 0x....      BL       sendDataUART1
    223          		}
    224                  EXTI_ClearITPendingBit(EXTI_Line13);
   \                     ??EXTI15_10_IRQHandler_3: (+1)
   \   0000006E   0xF44F 0x5000      MOV      R0,#+8192
   \   00000072   0x.... 0x....      BL       EXTI_ClearITPendingBit
    225          	}
    226          }
   \                     ??EXTI15_10_IRQHandler_2: (+1)
   \   00000076   0xBD1F             POP      {R0-R4,PC}       ;; return
    227          
    228          

   \                                 In section .text, align 2, keep-with-next
    229          void EXTI4_IRQHandler(void) { // when the button is pressed
   \                     EXTI4_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    230              if (EXTI_GetITStatus(EXTI_Line4) != RESET) {
   \   00000002   0x2010             MOVS     R0,#+16
   \   00000004   0x.... 0x....      BL       EXTI_GetITStatus
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00B             BEQ.N    ??EXTI4_IRQHandler_0
    231          		if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_4) == Bit_RESET) {
   \   0000000C   0x2110             MOVS     R1,#+16
   \   0000000E   0x....             LDR.N    R0,??DataTable9_2  ;; 0x40011000
   \   00000010   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD102             BNE.N    ??EXTI4_IRQHandler_1
    232          			// TODO implement
    233                            mode = 1;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x....             LDR.N    R1,??DataTable9_7
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    234                            
    235          		}
    236          		EXTI_ClearITPendingBit(EXTI_Line4);
   \                     ??EXTI4_IRQHandler_1: (+1)
   \   0000001E   0x2010             MOVS     R0,#+16
   \   00000020   0x.... 0x....      BL       EXTI_ClearITPendingBit
    237          	}
    238          }
   \                     ??EXTI4_IRQHandler_0: (+1)
   \   00000024   0xBD01             POP      {R0,PC}          ;; return
    239          
    240          

   \                                 In section .text, align 2, keep-with-next
    241          void Delay(void) {
    242          	int i;
    243          
    244          	for (i = 0; i < 2000000; i++) {}
   \                     Delay: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE000             B.N      ??Delay_0
   \                     ??Delay_1: (+1)
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \                     ??Delay_0: (+1)
   \   00000006   0x....             LDR.N    R1,??DataTable9_9  ;; 0x1e8480
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xDBFB             BLT.N    ??Delay_1
    245          }
   \   0000000C   0x4770             BX       LR               ;; return
    246          

   \                                 In section .text, align 2, keep-with-next
    247          void sendDataUART1(uint16_t data) {
   \                     sendDataUART1: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0001             MOVS     R1,R0
    248          	/* Wait till TC is set */
    249          	while ((USART1->SR & USART_SR_TC) == 0);
   \                     ??sendDataUART1_0: (+1)
   \   00000004   0x....             LDR.N    R0,??DataTable9_6  ;; 0x40013800
   \   00000006   0x8800             LDRH     R0,[R0, #+0]
   \   00000008   0x0640             LSLS     R0,R0,#+25
   \   0000000A   0xD5FB             BPL.N    ??sendDataUART1_0
    250          	USART_SendData(USART1, data);
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x....             LDR.N    R0,??DataTable9_6  ;; 0x40013800
   \   00000010   0x.... 0x....      BL       USART_SendData
    251          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    252          
    253          
    254          
    255          
    256          

   \                                 In section .text, align 2, keep-with-next
    257          int main(void)
    258          {
   \                     main: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    259          
    260              SystemInit();
   \   00000002   0x.... 0x....      BL       SystemInit
    261          
    262              RCC_Configure();
   \   00000006   0x.... 0x....      BL       RCC_Configure
    263          
    264              GPIO_Configure();
   \   0000000A   0x.... 0x....      BL       GPIO_Configure
    265          
    266              EXTI_Configure();
   \   0000000E   0x.... 0x....      BL       EXTI_Configure
    267          
    268              USART1_Init();
   \   00000012   0x.... 0x....      BL       USART1_Init
    269          
    270              NVIC_Configure();
   \   00000016   0x.... 0x....      BL       NVIC_Configure
    271              
    272              int i = 0;
   \   0000001A   0x2400             MOVS     R4,#+0
    273              
    274              while (1) {
    275              	// TODO: implement 
    276                if(mode == 2){
   \                     ??main_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable9_7
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2802             CMP      R0,#+2
   \   00000022   0xD004             BEQ.N    ??main_1
    277                  if(i == 0) i = 4;
    278                  i--;
    279                }
    280                else
    281                {
    282                  i++;
   \                     ??main_2: (+1)
   \   00000024   0x1C64             ADDS     R4,R4,#+1
    283                  if(i==4) i = 0;
   \   00000026   0x2C04             CMP      R4,#+4
   \   00000028   0xD105             BNE.N    ??main_3
   \   0000002A   0x2400             MOVS     R4,#+0
   \   0000002C   0xE003             B.N      ??main_3
    284                }
   \                     ??main_1: (+1)
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD100             BNE.N    ??main_4
   \   00000032   0x2404             MOVS     R4,#+4
   \                     ??main_4: (+1)
   \   00000034   0x1E64             SUBS     R4,R4,#+1
    285                
    286                if (i != 0) GPIOD->BSRR = GPIO_Pin_2;
   \                     ??main_3: (+1)
   \   00000036   0x2C00             CMP      R4,#+0
   \   00000038   0xD002             BEQ.N    ??main_5
   \   0000003A   0x2004             MOVS     R0,#+4
   \   0000003C   0x....             LDR.N    R1,??DataTable9_10  ;; 0x40011410
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    287                 if (i != 1) GPIOD->BSRR = GPIO_Pin_3; 
   \                     ??main_5: (+1)
   \   00000040   0x2C01             CMP      R4,#+1
   \   00000042   0xD002             BEQ.N    ??main_6
   \   00000044   0x2008             MOVS     R0,#+8
   \   00000046   0x....             LDR.N    R1,??DataTable9_10  ;; 0x40011410
   \   00000048   0x6008             STR      R0,[R1, #+0]
    288                 if (i != 2) GPIOD->BSRR = GPIO_Pin_4;
   \                     ??main_6: (+1)
   \   0000004A   0x2C02             CMP      R4,#+2
   \   0000004C   0xD002             BEQ.N    ??main_7
   \   0000004E   0x2010             MOVS     R0,#+16
   \   00000050   0x....             LDR.N    R1,??DataTable9_10  ;; 0x40011410
   \   00000052   0x6008             STR      R0,[R1, #+0]
    289                  if (i != 3) GPIOD->BSRR = GPIO_Pin_7;
   \                     ??main_7: (+1)
   \   00000054   0x2C03             CMP      R4,#+3
   \   00000056   0xD002             BEQ.N    ??main_8
   \   00000058   0x2080             MOVS     R0,#+128
   \   0000005A   0x....             LDR.N    R1,??DataTable9_10  ;; 0x40011410
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    290                 
    291              	// Delay
    292              	Delay();
   \                     ??main_8: (+1)
   \   0000005E   0x.... 0x....      BL       Delay
    293                  
    294                  GPIOD->BSRR = ~GPIO_Pin_All;
   \   00000062   0x....             LDR.N    R0,??DataTable9_11  ;; 0xffff0000
   \   00000064   0x....             LDR.N    R1,??DataTable9_10  ;; 0x40011410
   \   00000066   0x6008             STR      R0,[R1, #+0]
   \   00000068   0xE7D8             B.N      ??main_0
    295          
    296              }
    297              return 0;
                     ^
Warning[Pe111]: statement is unreachable
    298          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40021018         DC32     0x40021018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     mode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x001E8480         DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x40011410         DC32     0x40011410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0xFFFF0000         DC32     0xffff0000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x54 0x65          DC8 "Team10\015\012"
   \              0x61 0x6D    
   \              0x31 0x30    
   \              0x0D 0x0A    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Delay
      24   EXTI15_10_IRQHandler
        24   -> EXTI_ClearITPendingBit
        24   -> EXTI_GetITStatus
        24   -> GPIO_ReadInputDataBit
        24   -> sendDataUART1
       8   EXTI4_IRQHandler
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> GPIO_ReadInputDataBit
      16   EXTI_Configure
        16   -> EXTI_Init
        16   -> GPIO_EXTILineConfig
       8   GPIO_Configure
         8   -> GPIO_Init
       8   LED
         8   -> backwardLED
         8   -> forwardLED
       8   NVIC_Configure
         8   -> NVIC_Init
         8   -> NVIC_PriorityGroupConfig
         8   -> __NVIC_EnableIRQ
       8   RCC_Configure
         8   -> RCC_APB2PeriphClockCmd
       8   USART1_IRQHandler
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
      24   USART1_Init
        24   -> USART_Cmd
        24   -> USART_ITConfig
        24   -> USART_Init
       0   __NVIC_EnableIRQ
       8   main
         8   -> Delay
         8   -> EXTI_Configure
         8   -> GPIO_Configure
         8   -> NVIC_Configure
         8   -> RCC_Configure
         8   -> SystemInit
         8   -> USART1_Init
       8   sendDataUART1
         8   -> USART_SendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      12  ?_0
      14  Delay
     120  EXTI15_10_IRQHandler
      38  EXTI4_IRQHandler
     116  EXTI_Configure
     124  GPIO_Configure
      30  LED
     114  NVIC_Configure
      90  RCC_Configure
      60  USART1_IRQHandler
      70  USART1_Init
      30  __NVIC_EnableIRQ
     106  main
       4  mode
      22  sendDataUART1

 
   4 bytes in section .data
  12 bytes in section .rodata
 982 bytes in section .text
 
 982 bytes of CODE  memory
  12 bytes of CONST memory
   4 bytes of DATA  memory

Errors: none
Warnings: 5
